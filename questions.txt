Вопрос 1: "Какой самый эффективный способ конкатенации строк?"

Наиболее эффективным способом конкатенации строк считается strings.Builder -- тип, не так давно добавленный в Go.
Это аналог bytes.Buffer, но он отличается тем, что при вызове метода String()
не происходит повторого выделения памяти и данные не копируются.

Вопрос 2: "Что такое интерфейсы, как они применяются в Go?"

// Интерфейс -- это конструкция, которая нужна для того, чтобы определять и описывать некие методы, необходимые какому-то типу данных.

package main

import (
	"fmt"
	"reflect"
)

// Пусть интерфейс Phone имеет сигнатурное значение getInfo:
type Phone interface {
	GetInfo() string
}

// А также существуют типы Iphone12 и SamsungGalaxyS20:
type Iphone12 struct{}
type GalaxyS20 struct{}

// Эти типы данных удовлетворяют интерфейсу Phone, поскольку имеют сигнатурное значение getInfo:
func (Iphone12) GetInfo() string {
	return "Iphone 12 is made by Apple"
}
func (GalaxyS20) GetInfo() string {
	return "Galaxy S20 is made by Samsung"
}

// Благодаря этому, если мы определим функцию printInfo, которая принимает тип данных Phone,
func printInfo(p Phone) {
	fmt.Println(p.GetInfo())
}

// Мы сможем использовать эту функцию для типов Iphone12 и GalaxyS20,
// Ведь они также относятся к типу данных Phone благодаря удовлетворяемости одноимённому интерфейсу.
func main() {
	ip := Iphone12{}
	sg := GalaxyS20{}

	printInfo(ip) // Вывод: Iphone 12 is made by Apple
	printInfo(sg) // Вывод: Galaxy S20 is made by Samsung

	a := "a"
	b := "1"
	emptyInterface(a)
	emptyInterface(b)
}

// Помимо этого, интерфейс может быть пустым. В таком случае он принимает любой тип данных:

func emptyInterface(i interface{}) {
	switch reflect.TypeOf(i).Kind() {
	case reflect.String:
		fmt.Println(i.(string))
	case reflect.Int:
		fmt.Printf("%d", i.(int))
	}
}

Вопрос 3: "Чем отличаются RWMutex от Mutex?"

Mutex -- инструмент в пакете sync, который позволяет разграничить доступ к некоторым общим ресурсам, гарантируя, 
что только одна горутина имеет к ним доступ в определенный момент времени. 
И пока одна горутина не освободит общий ресурс, другая горутина не может с ним работать.

RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. Например, стандартный тип map.
Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, 
пока вы не отпустите мьютекс через .Unlock().
Перед чтением защищаемого объекта делается .RLock(), и только вызовы .Lock() в других горутинах блокируются, 
вызовы .RLock() спокойно проходят. Когда отпускаете мьютекс через .RUnlock(), 
ждущие вызовы .Lock() по очереди могут забирать мьютекс на себя.

Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.

Вопрос 4: "Чем отличаются буферизированные и небуферизированные каналы?"

Не буферизированный канал, также известный как синхронный канал, требует, чтобы отправитель и получатель были готовы одновременно. 
Когда отправитель отправляет сообщение в не буферизированный канал, он блокируется до тех пор, пока получатель не получит это сообщение. 
То же самое происходит, когда получатель пытается получить сообщение из не буферизированного канала - 
он блокируется, пока отправитель не отправит сообщение.

Буферизированный канал, с другой стороны, имеет фиксированную емкость, определенную при его создании. 
Отправитель может отправить сообщение в канал, даже если получатель не готов его принять. 
В этом случае сообщение сохраняется во внутреннем буфере канала. Получатель может получить сообщение из буферизированного канала, когда будет готов. 
Если буфер канала полностью заполнен, отправитель будет блокирован до тех пор, пока получатель не освободит место в буфере путем получения сообщения.

Таким образом, основное отличие между буферизированными и не буферизированными каналами заключается в том, 
что буферизированные каналы позволяют асинхронное взаимодействие между отправителем и получателем, 
позволяя отправителю продолжать работу, даже если получатель не готов принять сообщение. 
В то время как не буферизированные каналы требуют синхронного взаимодействия, где отправитель и получатель должны быть готовы одновременно.

Вопрос 5: "Какой размер у структуры struct{}{}?"

Размер структуры `struct{}{}` в языке Go равен нулю. 

Структура `struct{}{}` известна как пустая структура, или структура без полей. В языке Go структуры не занимают дополнительное место в памяти 
за счет неиспользуемых полей. Пустая структура не имеет полей, поэтому размер пустой структуры равен нулю.

Пустая структура может быть полезной, когда вам нужна структура без данных, например, для использования в качестве типа канала, 
чтобы указать на простое событие, или для использования в качестве ключа в карте, чтобы указать на присутствие или отсутствие элемента.

Вопрос 6: "Есть ли в Go перегрузка методов или операторов?"

В языке Go нет поддержки перегрузки методов или операторов, как в некоторых других языках программирования.

Перегрузка методов означает возможность определения нескольких методов с одинаковым именем, но с разными параметрами или типами входных данных. 
Такая возможность позволяет вызывать методы с разными наборами аргументов в зависимости от контекста. Однако в Go это не разрешено, 
и каждый метод должен иметь уникальное имя в рамках своей структуры или типа.
То же самое относится и к перегрузке операторов. В некоторых языках программирования можно определить различное поведение операторов в зависимости 
от типа данных операндов. Но в Go операторы имеют фиксированный набор операций, и их поведение не может быть изменено или перегружено для пользовательских типов данных.

Вместо перегрузки методов или операторов Go обычно рекомендует использовать именованные методы с разными именами для разных операций или функции 
с различными именами для разных вариантов функциональности. Это помогает сохранить ясность и понятность кода, а также избежать путаницы, 
которая может возникнуть при использовании перегрузки.

Вопрос 7: "В какой последовательности будут выведены элементы map[int]int?"

Порядок вывода элементов в `map[int]int` в языке Go не определен и может быть случайным.

`map` в Go - это неупорядоченная коллекция элементов, которая реализована в виде хэш-таблицы. 
Это означает, что элементы в `map` хранятся и доступны через ключи, и порядок их расположения в памяти не гарантирован.

При итерации по `map` или выводе его элементов, порядок, в котором они будут возвращены, 
может быть разным при каждом запуске программы или даже в рамках одного запуска, если в `map` происходят изменения.

Таким образом, нельзя полагаться на определенный порядок элементов в `map[int]int`. Если нужно упорядочить элементы, 
следует использовать другую структуру данных, такую как срез или отсортированную карту (например, `map[int]int` с использованием пакета `sort`).
Но сортировка требует времени, и ей нужна дополнительная память. 

Вопрос 8: "В чем разница make и new?"

Разница между `make` и `new` в языке Go заключается в их функциональности и том, как они используются для создания объектов.

`new` - это встроенная функция, которая создает нулевое значение указанного типа и возвращает указатель на него. 
Она используется для создания нового экземпляра указанного типа и инициализации его нулевыми значениями. 
Например, `new(T)` вернет указатель на новый экземпляр типа `T` с нулевыми значениями для всех его полей.

`make` - это встроенная функция, которая создает и инициализирует сложные типы данных, такие как срезы, карты и каналы. 
Она используется только для создания и инициализации этих типов данных, и возвращает инициализированный экземпляр указанного типа. 
Например, `make([]int, 0, 10)` создаст и инициализирует пустой срез `[]int` с длиной 0 и емкостью 10.

Таким образом, основная разница между `make` и `new` заключается в том, что 
`new` используется для создания и инициализации обычных типов данных, 
в то время как `make` используется только для создания и инициализации сложных типов данных, таких как срезы, карты и каналы.

Вопрос 9: "Сколько существует способов задать переменную типа slice или map?"

Для переменных типа slice:

1. Использование литерала slice: `var mySlice = []int{1, 2, 3}`. 
В этом случае тип slice будет автоматически определён на основе переданных значений.

2. Использование функции `make`: `var mySlice = make([]int, 5, 10)`. 
Функция `make` создаёт новый slice указанной длины и емкости.

3. Использование оператора среза: `var mySlice = []int{}`. 
При этом slice будет инициализирован пустым.

Для переменных типа map:

1. Использование литерала map: `var myMap = map[string]int{"a": 1, "b": 2, "c": 3}`. 
В этом случае тип map будет автоматически определён на основе переданных пар "ключ-значение".

2. Использование функции `make`: `var myMap = make(map[string]int)`. 
Функция `make` создаёт новую map.

3. Инициализация пустой map: `var myMap = map[string]int{}`. 
В этом случае map будет инициализирована пустой.

Вопрос 10: "Что выведет данная программа и почему?"

func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

Данная программа выведет:

1
1

При вызове функции `update(p)` переменная `p` передается по значению (копируется указатель), поэтому изменения, 
внесенные внутри функции `update`, не влияют на оригинальный указатель `p` в функции `main`. 
Внутри функции `update` создается новая переменная `b` со значением 2, и указатель `p` изменяется на указатель на эту новую переменную. 
Однако это изменение не отражается на оригинальном указателе `p` в функции `main`.

Поэтому после вызова `update(p)` второй вызов `fmt.Println(*p)` возвращает значение, 
на которое указывал оригинальный указатель `p` до вызова функции `update`, то есть значение 1.

Вопрос 11: "Что выведет данная программа и почему?"

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

Данная программа будет выводить числа от 0 до 4 в произвольном порядке, а затем строку "exit".

При каждой итерации цикла `for` мы добавляем 1 к счетчику `wg` с помощью метода `Add(1)`, 
чтобы уведомить `WaitGroup`, что мы запускаем новую горутину. Затем мы запускаем анонимную функцию в новой горутине.
Внутри анонимной функции мы выводим значение `i`, которое передается в качестве аргумента. 
Затем мы вызываем метод `Done()` для уведомления `WaitGroup`, что горутина завершилась.

Однако проблема заключается в передаче `wg` в анонимную функцию по значению, а не по ссылке. 
Каждая горутина получает свою собственную копию `wg`, и изменения, внесенные в одной горутине, не влияют на остальные горутины.
Поэтому, когда мы дойдём до wg.Wait(), главная горутина остановится, и мы получим панику: 
fatal error: all goroutines are asleep - deadlock!

Если мы поменяем (wg, i) на (&wg, i), код придёт в норму. 

Вопрос 12: "Что выведет данная программа и почему?"

func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}

Эта программа выведет 0. 

В данном коде используется оператор `:=` для создания новой переменной `n` внутри блока `if`. 
Эта новая переменная `n` имеет локальную область видимости только внутри блока `if`.

Внутри блока `if` значение переменной `n` увеличивается на 1 (`n++`), 
но это изменение не отразится на оригинальной переменной `n` во внешней области видимости.

Поэтому после выхода из блока `if` при вызове `fmt.Println(n)` будет выведено значение оригинальной переменной `n`, равное 0.

Вопрос 13: "Что выведет данная программа и почему?"

func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

Данная программа выведет `[100, 2, 3, 4, 5]`.

В функции `someAction` мы изменяем первый элемент среза `v` на значение 100 (`v[0] = 100`). 
Это изменение отразится на оригинальном срезе `a` в функции `main`, так как срезы в Go передаются по ссылке.

Однако при вызове `append(v, b)` внутри функции `someAction` создается новый срез, к которому добавляется значение `b`.
Но этот новый срез не влияет на оригинальный срез `a` в функции `main`.

Поэтому после вызова `someAction(a, 6)` оригинальный срез `a` в функции `main` будет содержать 
измененное значение первого элемента (100), а не будет содержать добавленное значение `b` (6).

Вопрос 14: "Что выведет данная программа и почему?"

func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

Данная программа выведет `[b b a] [a a]`.

В данном коде мы определяем анонимную функцию и сразу же вызываем ее, 
передавая ей срез `slice` в качестве аргумента. 
Внутри анонимной функции мы сначала добавляем элемент "a" в конец среза `slice` с помощью `append(slice, "a")`. 
Тем не менее этот вызов `append` создает новый срез, который не влияет на оригинальный срез `slice`.
Затем мы изменяем значения первых двух элементов среза `slice` на "b" (`slice[0] = "b"` и `slice[1] = "b"`).

В результате при вызове `fmt.Print(slice)` внутри анонимной функции будет выведен срез `[b b a]`, 
который является результатом изменений внутри функции.

После вызова анонимной функции при вызове `fmt.Print(slice)` вне анонимной функции будет выведен исходный срез `[a a]`, 
так как изменения, внесенные внутри анонимной функции, не затрагивают оригинальный срез `slice` вне функции.