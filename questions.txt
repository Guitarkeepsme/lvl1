Вопрос 1: "Какой самый эффективный способ конкатенации строк?"

Наиболее эффективным способом конкатенации строк считается strings.Builder -- тип, не так давно добавленный в Go.
Это аналог bytes.Buffer, но он отличается тем, что при вызове метода String()
не происходит повторого выделения памяти и данные не копируются.

Вопрос 2: "Что такое интерфейсы, как они применяются в Go?"

// Интерфейс -- это конструкция, которая нужна для того, чтобы определять и описывать некие методы, необходимые какому-то типу данных.

package main

import (
	"fmt"
	"reflect"
)

// Пусть интерфейс Phone имеет сигнатурное значение getInfo:
type Phone interface {
	GetInfo() string
}

// А также существуют типы Iphone12 и SamsungGalaxyS20:
type Iphone12 struct{}
type GalaxyS20 struct{}

// Эти типы данных удовлетворяют интерфейсу Phone, поскольку имеют сигнатурное значение getInfo:
func (Iphone12) GetInfo() string {
	return "Iphone 12 is made by Apple"
}
func (GalaxyS20) GetInfo() string {
	return "Galaxy S20 is made by Samsung"
}

// Благодаря этому, если мы определим функцию printInfo, которая принимает тип данных Phone,
func printInfo(p Phone) {
	fmt.Println(p.GetInfo())
}

// Мы сможем использовать эту функцию для типов Iphone12 и GalaxyS20,
// Ведь они также относятся к типу данных Phone благодаря удовлетворяемости одноимённому интерфейсу.
func main() {
	ip := Iphone12{}
	sg := GalaxyS20{}

	printInfo(ip) // Вывод: Iphone 12 is made by Apple
	printInfo(sg) // Вывод: Galaxy S20 is made by Samsung

	a := "a"
	b := "1"
	emptyInterface(a)
	emptyInterface(b)
}

// Помимо этого, интерфейс может быть пустым. В таком случае он принимает любой тип данных:

func emptyInterface(i interface{}) {
	switch reflect.TypeOf(i).Kind() {
	case reflect.String:
		fmt.Println(i.(string))
	case reflect.Int:
		fmt.Printf("%d", i.(int))
	}
}

Вопрос 3: "Чем отличаются RWMutex от Mutex?"

Mutex -- инструмент в пакете sync, который позволяет разграничить доступ к некоторым общим ресурсам, гарантируя, 
что только одна горутина имеет к ним доступ в определенный момент времени. 
И пока одна горутина не освободит общий ресурс, другая горутина не может с ним работать.

RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. Например, стандартный тип map.
Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, 
пока вы не отпустите мьютекс через .Unlock().
Перед чтением защищаемого объекта делается .RLock(), и только вызовы .Lock() в других горутинах блокируются, 
вызовы .RLock() спокойно проходят. Когда отпускаете мьютекс через .RUnlock(), 
ждущие вызовы .Lock() по очереди могут забирать мьютекс на себя.

Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.

Вопрос 4: "Чем отличаются буферизированные и небуферизированные каналы?"

Не буферизированный канал, также известный как синхронный канал, требует, чтобы отправитель и получатель были готовы одновременно. 
Когда отправитель отправляет сообщение в не буферизированный канал, он блокируется до тех пор, пока получатель не получит это сообщение. 
То же самое происходит, когда получатель пытается получить сообщение из не буферизированного канала - 
он блокируется, пока отправитель не отправит сообщение.

Буферизированный канал, с другой стороны, имеет фиксированную емкость, определенную при его создании. 
Отправитель может отправить сообщение в канал, даже если получатель не готов его принять. 
В этом случае сообщение сохраняется во внутреннем буфере канала. Получатель может получить сообщение из буферизированного канала, когда будет готов. 
Если буфер канала полностью заполнен, отправитель будет блокирован до тех пор, пока получатель не освободит место в буфере путем получения сообщения.

Таким образом, основное отличие между буферизированными и не буферизированными каналами заключается в том, 
что буферизированные каналы позволяют асинхронное взаимодействие между отправителем и получателем, 
позволяя отправителю продолжать работу, даже если получатель не готов принять сообщение. 
В то время как не буферизированные каналы требуют синхронного взаимодействия, где отправитель и получатель должны быть готовы одновременно.

Вопрос 5: "Какой размер у структуры struct{}{}?"

Размер структуры `struct{}{}` в языке Go равен нулю. 

Структура `struct{}{}` известна как пустая структура, или структура без полей. В языке Go структуры не занимают дополнительное место в памяти 
за счет неиспользуемых полей. Пустая структура не имеет полей, поэтому размер пустой структуры равен нулю.

Пустая структура может быть полезной, когда вам нужна структура без данных, например, для использования в качестве типа канала, 
чтобы указать на простое событие, или для использования в качестве ключа в карте, чтобы указать на присутствие или отсутствие элемента.

Вопрос 6: "Есть ли в Go перегрузка методов или операторов?"

В языке Go нет поддержки перегрузки методов или операторов, как в некоторых других языках программирования.

Перегрузка методов означает возможность определения нескольких методов с одинаковым именем, но с разными параметрами или типами входных данных. 
Такая возможность позволяет вызывать методы с разными наборами аргументов в зависимости от контекста. Однако в Go это не разрешено, 
и каждый метод должен иметь уникальное имя в рамках своей структуры или типа.
То же самое относится и к перегрузке операторов. В некоторых языках программирования можно определить различное поведение операторов в зависимости 
от типа данных операндов. Но в Go операторы имеют фиксированный набор операций, и их поведение не может быть изменено или перегружено для пользовательских типов данных.

Вместо перегрузки методов или операторов Go обычно рекомендует использовать именованные методы с разными именами для разных операций или функции 
с различными именами для разных вариантов функциональности. Это помогает сохранить ясность и понятность кода, а также избежать путаницы, 
которая может возникнуть при использовании перегрузки.

Вопрос 7: "В какой последовательности будут выведены элементы map[int]int?"

Порядок вывода элементов в `map[int]int` в языке Go не определен и может быть случайным.

`map` в Go - это неупорядоченная коллекция элементов, которая реализована в виде хэш-таблицы. 
Это означает, что элементы в `map` хранятся и доступны через ключи, и порядок их расположения в памяти не гарантирован.

При итерации по `map` или выводе его элементов, порядок, в котором они будут возвращены, 
может быть разным при каждом запуске программы или даже в рамках одного запуска, если в `map` происходят изменения.

Таким образом, нельзя полагаться на определенный порядок элементов в `map[int]int`. Если нужно упорядочить элементы, 
следует использовать другую структуру данных, такую как срез или отсортированную карту (например, `map[int]int` с использованием пакета `sort`).
Но сортировка требует времени, и ей нужна дополнительная память. 

Вопрос 8: "В чем разница make и new?"

Разница между `make` и `new` в языке Go заключается в их функциональности и том, как они используются для создания объектов.

`new` - это встроенная функция, которая создает нулевое значение указанного типа и возвращает указатель на него. 
Она используется для создания нового экземпляра указанного типа и инициализации его нулевыми значениями. 
Например, `new(T)` вернет указатель на новый экземпляр типа `T` с нулевыми значениями для всех его полей.

`make` - это встроенная функция, которая создает и инициализирует сложные типы данных, такие как срезы, карты и каналы. 
Она используется только для создания и инициализации этих типов данных, и возвращает инициализированный экземпляр указанного типа. 
Например, `make([]int, 0, 10)` создаст и инициализирует пустой срез `[]int` с длиной 0 и емкостью 10.

Таким образом, основная разница между `make` и `new` заключается в том, что 
`new` используется для создания и инициализации обычных типов данных, 
в то время как `make` используется только для создания и инициализации сложных типов данных, таких как срезы, карты и каналы.